#! /usr/bin/env python3

import os, sys, traceback
import cmd
import readline
import atexit
import re
import argparse
import torch
from pm_base import ShellBase
from pm_commands import Commands
from llm_service import LLMService


model = None
image = None


class Config:
    pass


def prepare_shell( server_mode=False ):
    """Any preparation or configuration before launching the Shell process
    should go here
    """
    
    #Configure matplotlib backend before any imports that use pyplot.
    import matplotlib
    if server_mode:
        matplotlib.use( 'Agg' )  # Non-interactive backend for server mode
    else:
        matplotlib.use( 'TkAgg' )  # Interactive backend for interactive mode


class Shell( ShellBase, Commands, cmd.Cmd ):
    def __init__( self, config, server_mode=False ):
        super().__init__( server_mode=server_mode )
        self.config = config
        self.rc_lines = []
        self.dataset = None
        self.compare = None
        self.data_post_process_fn = None
        #self.use_rawinput = False
        self.cur_frame = sys._getframe().f_back

        self.load_and_execute_rc_file()
        self.init_history( histfile=".pmdebug_history" )
        atexit.register( self.save_history, histfile=".pmdebug_history" )

        if hasattr( config, 'dataset' ) and config.dataset:
            self.do_set_dataset( config.dataset )
            self.load_first_image_from_dataset()

        # Initialize LLM service
        try:
            # Use path relative to this script's location
            script_dir = os.path.dirname( os.path.abspath( __file__ ) )
            service_config_file = os.path.join( script_dir, "llm_service_config.yaml" )
            self.llm_service = LLMService( service_config_file )
            self.llm_service.create_service()
        except Exception as e:
            self.llm_service = None
            self.error( f"WARNING: LLM service initialization failed with {e}" )


    ##############################################
    # Functions overridden from base class go here
    ##############################################
    def precmd( self, line ):
        if line.find( " " ) > 0:
            args = line.split( " " )
            map( str.strip, args )
            c = "{}_{}".format( args.pop( 0 ), args.pop( 0 ) )
            if ( callable( getattr( self, "do_" + c, None ) ) ):
                line = "{} {}".format( c, " ".join( args ) )        
        return line


    def default( self, line ):
        if line[ :1 ] == '!':
            line  = line[ 1: ]

        is_assign = False
        if line.find( '=' ) > 0:
            var, _ = line.split( '=', maxsplit=1 )
            var = var.strip()
            is_assign = True

        locals = self.cur_frame.f_locals
        globals = self.cur_frame.f_globals
        
        try:
            code = compile( line + "\n", "<stdin>", "single" )
            saved_stdin = sys.stdin
            saved_stdout = sys.stdout
            sys.stdin = self.stdin
            sys.stdout = self.stdout

            try:
                exec( code, globals, locals )
            finally:
                sys.stdin = saved_stdin
                sys.stdout = saved_stdout
        except:
            exec_info = sys.exc_info()[ :2 ]
            self.error( traceback.format_exception_only( *exec_info )[ -1 ].strip() )
        else:
            if is_assign and var and var in self.models:
                self.message( "Resyncing model \"{}\"".format( var ) )
                self.resync_model( var )


    ####################################################
    # Helper functions to debugger functionality go here
    ####################################################
    def expand_path( self, path ):
        """Expand environment variables and user home directory in path
        """
        if path is None:
            return None
        return os.path.expandvars( os.path.expanduser( path ) )


    def expand_config_paths( self ):
        """Expand environment variables in all path-related config attributes
        """
        path_attrs = [ 'image_path', 'checkpoint_path', 'dataset', 'train_path', 'val_path' ]
        for attr in path_attrs:
            if hasattr( self.config, attr ):
                value = getattr( self.config, attr )
                if value:
                    setattr( self.config, attr, self.expand_path( value ) )


    def load_first_image_from_dataset( self ):
        """Load the first image from the dataset if available
        """
        if self.dataset is None:
            return

        global image            
        self.message( "Loading first image from dataset...", end="" )
        try:
            self.dataset.next()
            image = self.dataset.load()
            self.message( "Done" )
        except Exception as e:
            self.message( "FAILED")


    def pre_process_rc_line( self, line ):
        """Process rc file line to handle quoted and unquoted paths
        Automatically adds quotes around unquoted paths in config assignments
        """
        # Match pattern: config.something = value
        match = re.match( r'^\s*(config\.\w+)\s*=\s*(.+)$', line )
        if not match:
            return line

        config_var = match.group( 1 )
        value = match.group( 2 ).strip()

        # Check if value is already quoted
        if (value.startswith( '"' ) and value.endswith( '"' )) or \
           (value.startswith( "'" ) and value.endswith( "'" )):
            return line
        else:
            return '{} = "{}"'.format( config_var, value )


    def exec_rc( self ):
        if not self.rc_lines:
            return
        self.message( "\nReading rc file...", end="" )

        self.stack.append( self.quiet )
        self.quiet = True
        num = 1
        while self.rc_lines:
            line = self.rc_lines.pop( 0 ).strip()
            self.message( "{}: {}".format( num, line ), end="" )
            num += 1
            if not line or "#" in line[ 0 ]:
                self.message()
                continue
            processed_line = self.pre_process_rc_line( line )
            self.onecmd( self.precmd( processed_line ) )
        self.message()
        self.expand_config_paths()
        self.quiet = self.stack.pop()
        self.message( "Done" )


    def load_and_execute_rc_file( self ):
        """
        Look for .pmdebugrc in current directory first, then in home directory,
        then in script directory. Load and execute the first one found.
        """
        rc_file = None
        if os.path.exists( ".pmdebugrc" ):
            rc_file = ".pmdebugrc"
        elif os.path.exists( os.path.expanduser( "~/.pmdebugrc" ) ):
            rc_file = os.path.expanduser( "~/.pmdebugrc" )
        else:
            script_dir = os.path.dirname( os.path.abspath( __file__ ) )
            rc_file = os.path.join( script_dir, ".pmdebugrc" )

        if rc_file:
            try:
                with open( rc_file ) as f:
                    self.rc_lines.extend( f )
            except OSError:
                pass
        self.exec_rc()


    def init_history( self, histfile ):
        try:
            readline.read_history_file( histfile )
        except FileNotFoundError:
            pass        
        readline.set_history_length( 2000 )
        readline.set_auto_history( True )


    def save_history( self, histfile ):
        self.message( "Saving history" )
        readline.write_history_file( histfile )


    def safe_mode( self ):
        os.environ[ "PYTORCH_ENABLE_MPS_FALLBACK" ] = "1"
        os.environ[ "OMP_NUM_THREADS" ] = "1"
        os.environ[ "MKL_NUM_THREADS" ] = "1"

        # Force MKL to use safe path
        os.environ[ "MKL_DEBUG_CPU_TYPE" ] = "5"
        
        torch.set_num_threads( 1 )
        torch.set_num_interop_threads( 1 )


    def _cmdloop( self, intro_header ):
        self.message( "Welcome to the debug shell!" )
        while True:
            try:
                self.allow_kbdint = True
                self.cmdloop( intro_header )
                self.allow_kbdint = False
                break
            except KeyboardInterrupt:
                self.message( "\n**Keyboard Interrupt" )
            except ( AttributeError, TypeError, NameError ) as e:
                self.error( e )
                traceback.print_exc()
            except ( RuntimeError, IndexError ):
                traceback.print_exc()

if __name__ == "__main__":
    # Parse command-line arguments
    parser = argparse.ArgumentParser( description='PyTorch Model Debug Shell' )
    parser.add_argument( '--safe-mode', action='store_true',
                        help='Enable safe mode (sets environment variables for CPU threading)' )
    args = parser.parse_args()

    # Configure matplotlib backend before creating shell
    prepare_shell( server_mode=False )

    config = Config()
    shell = Shell( config )

    # Call safe_mode() before doing anything if requested
    if args.safe_mode:
        shell.message( "Enabling safe mode..." )
        shell.safe_mode()

    shell.prompt = '>> '
    shell._cmdloop( "" )